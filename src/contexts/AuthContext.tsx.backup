'use client';

import {
  createContext,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
  useCallback,
  ReactNode,
} from 'react';
import type { User } from '@supabase/supabase-js';
import { supabase } from '../lib/supabase';

interface TenantMembership {
  tenant_id: string;
  tenant_slug: string;
  tenant_name: string;
  role: 'super_admin' | 'admin' | 'manager' | 'cashier';
}

interface UserAccessStatus {
  is_super_admin: boolean;
  memberships: TenantMembership[];
  user_id: string;
  user_email: string;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  accessStatus: UserAccessStatus | null;
  currentTenant: TenantMembership | null;
  signIn: (email: string, password: string) => Promise<void>;
  signInWithGoogle: (redirectTo?: string) => Promise<void>;
  signOut: () => Promise<void>;
  setCurrentTenant: (tenant: TenantMembership | null) => void;
  refreshAccessStatus: () => Promise<void>;
  isAuthenticated: boolean;
  isSuperAdmin: boolean;
  hasTenantAccess: boolean;
  isTenantAdmin: boolean;
  isTenantSuperAdmin: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const RESERVED = new Set(['admin','login','checkout','orders','invoice','success','sadmin']);

function getTenantSlugFromURL(): string | null {
  if (typeof window === 'undefined') return null;
  const p = window.location.pathname.split('/').filter(Boolean);
  if (!p.length) return null;
  return RESERVED.has(p[0].toLowerCase()) ? null : p[0].toLowerCase();
}

function getSiteURL() {
  return import.meta.env.VITE_SITE_URL || (typeof window !== 'undefined' ? window.location.origin : '');
}

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [accessStatus, setAccessStatus] = useState<UserAccessStatus | null>(null);
  const [currentTenant, _setCurrentTenant] = useState<TenantMembership | null>(null);
  const refreshingRef = useRef(false);
  const mountedRef = useRef(true);

  const setCurrentTenant = useCallback((t: TenantMembership | null) => _setCurrentTenant(t), []);

  const signIn = useCallback(async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw new Error(error.message);
  }, []);

  const signInWithGoogle = useCallback(async (redirectTo?: string) => {
    const site = getSiteURL();
    const slug = getTenantSlugFromURL();
    const cb = redirectTo || `${site}/auth/callback${slug ? `?tenant=${encodeURIComponent(slug)}` : ''}`;
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: { redirectTo: cb, queryParams: { access_type: 'offline', prompt: 'consent' } }
    });
    if (error) throw new Error(error.message);
  }, []);

  const signOut = useCallback(async () => {
    setUser(null); setAccessStatus(null); setCurrentTenant(null);
    const { error } = await supabase.auth.signOut();
    if (error) throw new Error(error.message);
  }, [setCurrentTenant]);

  const refreshAccessStatus = useCallback(async () => {
    if (refreshingRef.current) return;
    refreshingRef.current = true;
    setLoading(true);
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        setAccessStatus(null);
        const slug = getTenantSlugFromURL();
        setCurrentTenant(slug ? {
          tenant_id: `public-${slug}`,
          tenant_slug: slug,
          tenant_name: slug.replace(/-/g,' ').replace(/^\w/, c => c.toUpperCase()),
          role: 'cashier'
        } : null);
        return;
      }
      const { data, error } = await supabase.rpc('get_user_access_status');
      if (error) throw error;
      const status = data as UserAccessStatus;
      setAccessStatus(status);
      const urlSlug = getTenantSlugFromURL();
      const selected = (urlSlug && status.memberships.find(m => m.tenant_slug === urlSlug))
        || status.memberships[0] || null;
      setCurrentTenant(selected);
    } finally {
      refreshingRef.current = false;
      if (mountedRef.current) setLoading(false);
    }
  }, [setCurrentTenant]);

  useEffect(() => {
    mountedRef.current = true;
    (async () => {
      setLoading(true);
      try {
        const { data: { session } } = await supabase.auth.getSession();
        setUser(session?.user ?? null);
        await refreshAccessStatus();
      } finally {
        if (mountedRef.current) setLoading(false);
      }
    })();
    const { data } = supabase.auth.onAuthStateChange(async (_event, session) => {
      setUser(session?.user ?? null);
      if (_event === 'SIGNED_IN' || _event === 'TOKEN_REFRESHED') {
        await refreshAccessStatus(); // no redirect here
      }
      if (_event === 'SIGNED_OUT') {
        setAccessStatus(null);
        const slug = getTenantSlugFromURL();
        setCurrentTenant(slug ? {
          tenant_id: `public-${slug}`,
          tenant_slug: slug,
          tenant_name: slug.replace(/-/g,' ').replace(/^\w/, c => c.toUpperCase()),
          role: 'cashier'
        } : null);
      }
    });
    return () => { mountedRef.current = false; data.subscription.unsubscribe(); };
  }, [refreshAccessStatus]);

  const isAuthenticated = !!user;
  const isSuperAdmin = !!accessStatus?.is_super_admin;
  const hasTenantAccess = (accessStatus?.memberships.length ?? 0) > 0;
  const isTenantAdmin = currentTenant?.role === 'admin' || currentTenant?.role === 'super_admin';
  const isTenantSuperAdmin = currentTenant?.role === 'super_admin';

  const value: AuthContextType = {
    user, loading, accessStatus, currentTenant,
    signIn, signInWithGoogle, signOut, setCurrentTenant, refreshAccessStatus,
    isAuthenticated, isSuperAdmin, hasTenantAccess, isTenantAdmin, isTenantSuperAdmin,
  };
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within an AuthProvider');
  return ctx;
}
